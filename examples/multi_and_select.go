package main

/*
#include <stdlib.h>
// #include <sys/select.h> // No longer needed for select
// static inline void go_FD_ZERO(void *set) { FD_ZERO((fd_set*)set); }
// static inline void go_FD_SET(int sysfd, void *set) { FD_SET(sysfd, (fd_set*)set); }
// static inline int go_FD_ISSET(int sysfd, void *set) { return FD_ISSET(sysfd, (fd_set*)set); }
*/
import "C" // Still needed for C.int, C.long if used by curl package types

import (
	curl "github.com/BridgeSenseDev/go-curl-impersonate"
	// "syscall" // No longer needed for FdSet/Select/Timeval
	"fmt"
	"time" // For time.Sleep and time.Duration
)

// FD_ZERO, FD_SET, FD_ISSET are no longer needed.
// func FD_ZERO(set *syscall.FdSet) { ... }
// func FD_SET(sysfd int, set *syscall.FdSet) { ... }
// func FD_ISSET(sysfd int, set *syscall.FdSet) bool { ... }

func main() {
	var (
		still_running int = 1 // Initialize to 1 to start the loop
		err           error
	)

	ch1 := curl.EasyInit()
	ch2 := curl.EasyInit()
	defer ch1.Cleanup() // Ensure cleanup happens
	defer ch2.Cleanup() // Ensure cleanup happens

	ch1.Setopt(curl.OPT_URL, "http://www.163.com")
	ch1.Setopt(curl.OPT_HEADER, 0)
	ch1.Setopt(curl.OPT_VERBOSE, true)
	ch2.Setopt(curl.OPT_URL, "http://www.baidu.com")
	ch2.Setopt(curl.OPT_HEADER, 0)
	ch2.Setopt(curl.OPT_VERBOSE, true)

	mh := curl.MultiInit()
	defer mh.Cleanup() // Ensure cleanup happens

	mh.AddHandle(ch1)
	mh.AddHandle(ch2)

	fmt.Println("Starting multi perform loop with curl_multi_wait...")

	// Initial perform to get things started
	still_running, err = mh.Perform()
	if err != nil {
		fmt.Printf("Initial mh.Perform() error: %s\n", err)
		// Decide if fatal or try to continue
	}
	fmt.Printf("Initial perform, still_running: %d\n", still_running)

	for {
		// Process any messages generated by the last Perform()
		for {
			msg, msgs_in_queue := mh.Info_read()
			// msgs_in_queue is the total number of messages still in the queue *after* this one has been read.
			// If msg is nil, it means curl_multi_info_read returned NULL, indicating no more messages at this moment.
			if msg == nil { // No more messages in queue right now
				break
			}
			if msg.Easy_handle != nil { // Check if easy_handle is valid
				fmt.Printf("Message for easy handle %p: %s (result: %s). Msgs left in queue: %d\n",
					msg.Easy_handle, msg.Msg.String(), msg.DoneResult.Error(), msgs_in_queue)
			} else {
				fmt.Printf("Message with nil easy handle: %s (result: %s). Msgs left in queue: %d\n",
					msg.Msg.String(), msg.DoneResult.Error(), msgs_in_queue)
			}

			if msg.Msg == curl.GetCurlmsgDone() {
				// A transfer is complete.
				// You would typically remove the handle and clean it up here.
				// For this example, we'll defer cleanup.
				// mh.RemoveHandle(msg.Easy_handle)
				// msg.Easy_handle.Cleanup()
				fmt.Printf("Transfer for handle %p finished with code %s.\n", msg.Easy_handle, msg.DoneResult.Error())
			}
		}

		if still_running == 0 {
			fmt.Println("All transfers completed.")
			break
		}

		var wait_timeout_ms C.long = 1000 // Default wait time if Timeout() fails or returns < 0
		curl_timeout_val, err_timeout := mh.Timeout()

		if err_timeout != nil {
			fmt.Printf("Error multi_timeout: %s, using default %dms wait\n", err_timeout, wait_timeout_ms)
		} else if curl_timeout_val == 0 {
			// libcurl wants to be called again immediately
			fmt.Println("Timeout is 0, calling Perform again immediately.")
			still_running, err = mh.Perform()
			if err != nil {
				fmt.Printf("Error multi_perform (after timeout 0): %s\n", err)
				// Potentially sleep to avoid tight loop on persistent error
				time.Sleep(100 * time.Millisecond)
			}
			fmt.Printf("Perform (after 0 timeout), still_running: %d\n", still_running)
			continue // Restart loop to process messages and check still_running
		} else if curl_timeout_val > 0 {
			wait_timeout_ms = C.long(curl_timeout_val)
		} else { // curl_timeout_val < 0 (no specific timeout from libcurl)
			fmt.Printf("Timeout is %d, using default %dms wait\n", curl_timeout_val, wait_timeout_ms)
		}

		var numFdsReady C.int // This will be filled by Wait
		fmt.Printf("Calling Wait with timeout: %d ms\n", wait_timeout_ms)
		err = mh.Wait(nil, 0, int(wait_timeout_ms), &numFdsReady) // Pass nil and 0 for extra_fds

		if err != nil {
			fmt.Printf("Error multi_wait: %s. Sleeping briefly.\n", err)
			time.Sleep(100 * time.Millisecond) // Fallback sleep
			// After sleep, loop will call Perform again.
		} else {
			fmt.Printf("multi_wait returned, numFdsReady: %d\n", numFdsReady)
		}

		// After waiting (or if timeout was 0), call Perform again.
		// If numFdsReady > 0, Perform will process I/O. If timeout occurred, Perform will handle that.
		still_running, err = mh.Perform()
		if err != nil {
			fmt.Printf("Error multi_perform: %s\n", err)
			// If still_running is stuck > 0 and perform errors, it might be an unrecoverable situation for some handles.
			// Consider breaking or specific error handling.
		}
		fmt.Printf("Perform called, still_running: %d\n", still_running)
	}

	fmt.Println("Multi perform loop finished.")
	// Deferred cleanups will run here: mh.Cleanup(), ch1.Cleanup(), ch2.Cleanup()
}
